# [草稿] 代码之于

```
talk is cheap, show me the code.——林纳斯
```

一切编程的基础都建立在编码实践的基础上，只有你还在编写代码才能有所精进。

## 增删改查（CRUD,Create、Read、Update、Delete）

大部分的程序员都在开发增删改查的代码，其容易出错的点在于对然作用在同一个数据，但是同一个数据的 增删改查 操作的数据类型不一致。
这种就是弱类型语言写 增删改查 时速度快的原因，多种类型不做区分，也是事后修改代码痛苦的点，同一个数据在不同情况下类型其实是不同的。
随着项目的进展，这些类型会越来越多差异，等到爆发时，会发现要处理的字段太多。
强类型语言则更早暴露出这个问题，也更早地意识到类型的差异，事后修改的时候问题已经在每次修改被解决了，不会累计到一定程度造成混乱。
这种情况在前端尤其明显，是一种类型叠加态的状态。
后端因为接口都是分开的，所以问题不大，不会出现类型叠加态的情况。
这也就是为什么前端喜欢用弱类型语言而后端喜欢用强类型。

## 编程语言

说到编程语言不得不提编译原理，越来越多的实践发现，与其通过库扩展特性，必要的语言特性更是治本的解决方式。
通用编程语言开始给自身添加语言特性、大量的 DSL 由库开发而生。

### 领域特定语言 DSL（Domain-specific language）

常见的 DSL：

1. JSON
2. SQL
3. XML、HTML、YAML、TOML
4. CSS、SASS
5. 正则表达式

也有因为库的开发而生的 DSL: 

1. protobuf 为了 GRPC 。 
2. prisma 是为自身 ORM。
3. go-zero api 则是为自身 web 框架接口格式。
4. jsx/tsx 由 React 提出。
5. 各种字符串模板库定义的字符串生成模板语言，例如：go 标准库的 text/template 库; JSP 等。

领域特定语言有一个非常有趣的例子，PHP 早期是一个 HTML 的模板生成语言，随着功能不断扩展，最后脱离了 DSL 成为一个通用型语言。
这种出身也正是 PHP 在鄙视链底端的原因。
在某些老的 Java 开发者的印象里 PHP 和 JSP 是差不多的东西，他们没有发现 PHP 长足的改进，而 JSP 停止不前已经不可同日而语。
在某些老程序员也认为前端很简单，其实前端的复杂度也在十几年的发展后成倍增长，早已不再是以前的那个前端。
技术在不断发展，很多技术也早已经不再是以前的技术，技术可挖掘的深度也是翻翻，简单的比以前简单，难的也是比以前难。
很多不用写代码的前程序员为什么会认为新的技术简单，因为他们只看到新技术简单的部分，而没有深入到新技术难的部分。

### 通用编程语言

通用编程语言如果要流行起来，必须要在某个宽泛的领域成为专长。为了让自己在某个领域专长，通用型语言有向 DSL 靠拢的趋势。
Dart 发布之初推广乏力，后来 Flutter 出现，采用 Dart 作为主语言，Dart 为了 Flutter 做了语言修改，升级 2.0 版本（废弃掉 new 等）。
Kotlin 早期只是为了让代码量比 Java 少，所以早期 Kotlin 的安卓开发是只替代 Java。Kotlin + XML 相较 Java + XML 的优势不明显，所以一直无法撼动 Java。
随后又出现了  kotlin 转 XML 的方式，只写 kotlin 代码，但是 kotlin 代码会被编译成 XML，这样用户完全在写 kotlin 的写法也没让 kotlin 取代 Java。
但是就这样也历经数年，kotlin 的语言特性也改了又改扩展了又扩展，但是效果仍旧不佳，社区几乎都对 kotlin 不报希望了。
之后参考了 Flutter 的成果，Jetpack Compose 应运而生，kotlin 再一次扩展自身，终于顶替 Java + XML 的方式成为主流安卓开发模式。


## 优点就是缺点

```
那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。——茨威格《断头王后》
```

“优点”就是“缺点”，所以我更倾向于用“特点”来评论一个事物。
选用中性词可以防止被褒贬词义误导。
当你选用一个技术的时候就会得到它带来的优势，同时也必须接受它带来的弊端。
举个几个简单的例子：
1. 散列表有 O(1) 的查询，为什么还要用 O(log(n))的二叉树呢？因为散列表的 O(1) 是牺牲了数据顺序得到的，散列表的数据没有顺序。而二叉树保留了数据顺序。当你用了散列表后就要承受数据无序的弊端。
2. 数组可以随机访问，为什么还要链表呢？原因在于数组的扩容很耗费性能，元素顺序改变需要大面积复制。反观链表调整节点和创建节点就要轻很多。这就是为什么很多语言要求数组必须指定大小，且不可动态改变数组大小。

## 技术优化与资源管理

```
过早的优化是万恶之源。——高德纳
```

要做资源管理，首先你要了解手头的资源。过早的优化实则就是对资源不了解下的管理。
资源疲敝却想着争天下，就是妄人。资源丰盈却不思进取想着偏安一隅，就是废人。
因材施教你就知道，因地制宜就忘记了？凡事都要把注意力放在自身。

## 计算机术语

程序员时常调侃自己是“面向搜索引擎编程”、“面向 AI 编程”那么为什么还是会有很多人给了他搜索引擎和 AI 还是做不好项目呢？
一方面是技术知识匮乏，另一方面是技术术语不精确。一个“好的技术术语”，在搜索引擎时代就是“好的关键字”，在 AI 时代就是“好的提示词”，使用精准的术语可以让你事半功倍。虽然说一个人说不出术语并不能代表其没有使用过，但是却可以知道他没有系统地学习过，毕竟这个浮躁地时代，要让一个人沉下心去系统学习很难，常常也不会有条件允许你这么做，都是干起来边干边学，都是碎片化的知识。

- 数据库的 migration 中文直译“迁移”，其作用却是用代码构建数据库，术语“Code First”
- 数据库的 “Database First” 则是读取数据库结构生成代码的流程。
- 数据库的 replication 中文直译“复制”，其作用是同步数据，MySQL 的 binlog、PostgreSQL 的 WAL 都是其具体实现。

## 数据库

- 关系数据库（Relational DB）
- 键值对存储（KV store）
- 日志结构合并树（LSM-Tree）

不管是关系数据库还是键值对存储，都是基于 键值对 。
关系数据库其本质就是对 键值对 的进一步封装，让键值对看起来像一张二位的表。B+树就是键值对。
各种不同的存储引擎，就是使用不同实现的键值对，有的用 哈希、有的用 B+树、有的用跳表。

Redis 为什么相较 MySQL 快？因为它做得少，做得少就快。
MySQL 为什么相较 Redis 慢？因为它做得多，做得多就慢。


