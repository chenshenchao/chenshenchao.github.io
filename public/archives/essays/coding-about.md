# [草稿] 代码之于

```
talk is cheap, show me the code.——林纳斯
```

一切编程的基础都建立在编码实践的基础上，只有你还在编写代码才能有所精进。

## 增删改查（CRUD,Create、Read、Update、Delete）

大部分的程序员都在开发增删改查的代码，其容易出错的点在于对然作用在同一个数据，但是同一个数据的 增删改查 操作的数据类型不一致。
这种就是弱类型语言写 增删改查 时速度快的原因，多种类型不做区分，也是事后修改代码痛苦的点，同一个数据在不同情况下类型其实是不同的。
随着项目的进展，这些类型会越来越多差异，等到爆发时，会发现要处理的字段太多。
强类型语言则更早暴露出这个问题，也更早地意识到类型的差异，事后修改的时候问题已经在每次修改被解决了，不会累计到一定程度造成混乱。
这种情况在前端尤其明显，是一种类型叠加态的状态。
后端因为接口都是分开的，所以问题不大，不会出现类型叠加态的情况。
这也就是为什么前端喜欢用弱类型语言而后端喜欢用强类型。

## 优点就是缺点

```
那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。——茨威格《断头王后》
```

“优点”就是“缺点”，所以我更倾向于用“特点”来评论一个事物。
选用中性词可以防止被褒贬词义误导。
当你选用一个技术的时候就会得到它带来的优势，同时也必须接受它带来的弊端。
举个几个简单的例子：
1. 散列表有 O(1) 的查询，为什么还要用 O(log(n))的二叉树呢？因为散列表的 O(1) 是牺牲了数据顺序得到的，散列表的数据没有顺序。而二叉树保留了数据顺序。当你用了散列表后就要承受数据无序的弊端。
2. 数组可以随机访问，为什么还要链表呢？原因在于数组的扩容很耗费性能，元素顺序改变需要大面积复制。反观链表调整节点和创建节点就要轻很多。这就是为什么很多语言要求数组必须指定大小，且不可动态改变数组大小。

## 技术优化与资源管理

```
过早的优化是万恶之源。——高德纳
```

要做资源管理，首先你要了解手头的资源。过早的优化实则就是对资源不了解下的管理。
资源疲敝却想着争天下，就是妄人。资源丰盈却不思进取想着偏安一隅，就是废人。
因材施教你就知道，因地制宜就忘记了？凡事都要把注意力放在自身。

## 计算机术语

程序员时常调侃自己是“面向搜索引擎编程”、“面向 AI 编程”那么为什么还是会有很多人给了他搜索引擎和 AI 还是做不好项目呢？
一方面是技术知识匮乏，另一方面是技术术语不精确。一个“好的技术术语”，在搜索引擎时代就是“好的关键字”，在 AI 时代就是“好的提示词”，使用精准的术语可以让你事半功倍。虽然说一个人说不出术语并不能代表其没有使用过，但是却可以知道他没有系统地学习过，毕竟这个浮躁地时代，要让一个人沉下心去系统学习很难，常常也不会有条件允许你这么做，都是干起来边干边学，都是碎片化的知识。

- 数据库的 migration 中文直译“迁移”，其作用却是用代码构建数据库，术语“Code First”
- 数据库的 “Database First” 则是读取数据库结构生成代码的流程。
- 数据库的 replication 中文直译“复制”，其作用是同步数据，MySQL 的 binlog、PostgreSQL 的 WAL 都是其具体实现。

## 数据库

- 关系数据库（Relational DB）
- 键值对存储（KV store）
- 日志结构合并树（LSM-Tree）

不管是关系数据库还是键值对存储，都是基于 键值对 。
关系数据库其本质就是对 键值对 的进一步封装，让键值对看起来像一张二位的表。B+树就是键值对。
各种不同的存储引擎，就是使用不同实现的键值对，有的用 哈希、有的用 B+树、有的用跳表。

Redis 为什么相较 MySQL 快？因为它做得少，做得少就快。
MySQL 为什么相较 Redis 慢？因为它做得多，做得多就慢。


