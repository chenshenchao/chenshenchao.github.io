# [草稿] 代码之于

```
talk is cheap, show me the code.——林纳斯
```

一切编程的基础都建立在编码实践的基础上，只有你还在编写代码才能有所精进。

## 版本管理、Git 或者 SVN

因为一切的基础都建立在持续地写代码，所以管理代码成了程序员的必备技能。
我在很多老项目里面经常看到很多废弃的代码没有被删除，这种废弃代码成为了误导接手者的粪团，看了半天才发现，原来是废弃的，下面还有一份功能类似的真正使用代码。
这种废弃代码如果善于使用 Git 是完全不用和已有代码出现在同一个版本的，害怕丢失这些代码而保留完全没有必要留在每个版本。
所以善用 Git 可以很大程度让代码保持整洁。

## 增删改查（CRUD,Create、Read、Update、Delete）

大部分的程序员都在开发增删改查的代码，其容易出错的点在于对然作用在同一个数据，但是同一个数据的 增删改查 操作的数据类型不一致。
这种就是弱类型语言写 增删改查 时速度快的原因，多种类型不做区分，也是事后修改代码痛苦的点，同一个数据在不同情况下类型其实是不同的。
随着项目的进展，这些类型会越来越多差异，等到爆发时，会发现要处理的字段太多。
强类型语言则更早暴露出这个问题，也更早地意识到类型的差异，事后修改的时候问题已经在每次修改被解决了，不会累计到一定程度造成混乱。
这种情况在前端尤其明显，是一种类型叠加态的状态。
后端因为接口都是分开的，所以问题不大，不会出现类型叠加态的情况。
这也就是为什么前端喜欢用弱类型语言而后端喜欢用强类型。

## 编程语言

说到编程语言不得不提编译原理，越来越多的实践发现，与其通过库扩展特性，必要的语言特性更是治本的解决方式。
通用编程语言开始给自身添加语言特性、大量的 DSL 由库开发而生。

### 领域特定语言 DSL（Domain-specific language）

常见的 DSL：

1. JSON
2. SQL
3. XML、HTML、YAML、TOML
4. CSS、SASS
5. 正则表达式

也有因为库的开发而生的 DSL: 

1. protobuf 为了 GRPC 。 
2. prisma 是为自身 ORM。
3. go-zero api 则是为自身 web 框架接口格式。
4. jsx/tsx 由 React 提出。
5. 各种字符串模板库定义的字符串生成模板语言，例如：go 标准库的 text/template 库; JSP 等。

领域特定语言有一个非常有趣的例子，PHP 早期是一个 HTML 的模板生成语言，随着功能不断扩展，最后脱离了 DSL 成为一个通用型语言。
这种出身也正是 PHP 在鄙视链底端的原因。
在某些老的 Java 开发者的印象里 PHP 和 JSP 是差不多的东西，他们没有发现 PHP 长足的改进，而 JSP 停止不前已经不可同日而语。
在某些老程序员也认为前端很简单，其实前端的复杂度也在十几年的发展后成倍增长，早已不再是以前的那个前端。
技术在不断发展，很多技术也早已经不再是以前的技术，技术可挖掘的深度也是翻翻，简单的比以前简单，难的也是比以前难。
很多不用写代码的前程序员为什么会认为新的技术简单，因为他们只看到新技术简单的部分，而没有深入到新技术难的部分。

### 通用编程语言

通用编程语言如果要流行起来，必须要在某个宽泛的领域成为专长。为了让自己在某个领域专长，通用型语言有向 DSL 靠拢的趋势。
Dart 发布之初推广乏力，后来 Flutter 出现，采用 Dart 作为主语言，Dart 为了 Flutter 做了语言修改，升级 2.0 版本（废弃掉 new 等）。
Kotlin 早期只是为了让代码量比 Java 少，所以早期 Kotlin 的安卓开发是只替代 Java。Kotlin + XML 相较 Java + XML 的优势不明显，所以一直无法撼动 Java。
随后又出现了  kotlin 转 XML 的方式，只写 kotlin 代码，但是 kotlin 代码会被编译成 XML，这样用户完全在写 kotlin 的写法也没让 kotlin 取代 Java。
但是就这样也历经数年，kotlin 的语言特性也改了又改扩展了又扩展，但是效果仍旧不佳，社区几乎都对 kotlin 不报希望了。
之后参考了 Flutter 的成果，Jetpack Compose 应运而生，kotlin 再一次扩展自身，终于顶替 Java + XML 的方式成为主流安卓开发模式。


## 优点就是缺点

```
那时候她还太年轻，不知道所有命运馈赠的礼物，早已在暗中标好了价格。——茨威格《断头王后》
```

“优点”就是“缺点”，所以我更倾向于用“特点”来评论一个事物。
选用中性词可以防止被褒贬词义误导。
当你选用一个技术的时候就会得到它带来的优势，同时也必须接受它带来的弊端。
举个几个简单的例子：
1. 散列表有 O(1) 的查询，为什么还要用 O(log(n))的二叉树呢？因为散列表的 O(1) 是牺牲了数据顺序得到的，散列表的数据没有顺序。而二叉树保留了数据顺序。当你用了散列表后就要承受数据无序的弊端。
2. 数组可以随机访问，为什么还要链表呢？原因在于数组的扩容很耗费性能，元素顺序改变需要大面积复制。反观链表调整节点和创建节点就要轻很多。这就是为什么很多语言要求数组必须指定大小，且不可动态改变数组大小。

## 技术优化与资源管理

```
过早的优化是万恶之源。——高德纳
```

要做资源管理，首先你要了解手头的资源。过早的优化实则就是对资源不了解下的管理。
资源疲敝却想着争天下，就是妄人。资源丰盈却不思进取想着偏安一隅，就是废人。
因材施教你就知道，因地制宜就忘记了？凡事都要把注意力放在自身。

## 计算机术语

程序员时常调侃自己是“面向搜索引擎编程”、“面向 AI 编程”那么为什么还是会有很多人给了他搜索引擎和 AI 还是做不好项目呢？
一方面是技术知识匮乏，另一方面是技术术语不精确。一个“好的技术术语”，在搜索引擎时代就是“好的关键字”，在 AI 时代就是“好的提示词”，使用精准的术语可以让你事半功倍。虽然说一个人说不出术语并不能代表其没有使用过，但是却可以知道他没有系统地学习过，毕竟这个浮躁地时代，要让一个人沉下心去系统学习很难，常常也不会有条件允许你这么做，都是干起来边干边学，都是碎片化的知识。

- 数据库的 migration 中文直译“迁移”，其作用却是用代码构建数据库，术语“Code First”
- 数据库的 “Database First” 则是读取数据库结构生成代码的流程。
- 数据库的 replication 中文直译“复制”，其作用是同步数据，MySQL 的 binlog、PostgreSQL 的 WAL 都是其具体实现。

## 数据库

- 关系数据库（Relational DB）
- 键值对存储（KV store）
- 日志结构合并树（LSM-Tree）

不管是关系数据库还是键值对存储，都是基于 键值对 。
关系数据库其本质就是对 键值对 的进一步封装，让键值对看起来像一张二位的表。B+树就是键值对。
各种不同的存储引擎，就是使用不同实现的键值对，有的用 哈希、有的用 B+树、有的用跳表。

Redis 为什么相较 MySQL 快？因为它做得少，做得少就快。
MySQL 为什么相较 Redis 慢？因为它做得多，做得多就慢。

## 常见问题

### 屎山的成因

程序员常常会接手一些由其他人开发的历史遗留项目，而最常听到对这些项目的评价就是“屎山”。
为什么会这样呢？大概有以下几个原因：

1. 原开发者不会使用 git 或者 svn 导致留下一堆旧版本的代码没有删除，新旧代码混做一坨，废弃代码干扰新开发者阅读代码。
2. 原开发者没有认真对待命名和不会使用开发工具应对重构，常常一个函数的命名和期功能不一致。如“downloadFile”内部却是一个“下载”、“上传”、“其他操作”等一系列动作的组合，如果你问原开发者为什么命名为“downloadFile”？他会回答诸如“因为第一个步骤就是下载啊，之后扩展就保留原名了。”
3. 原开发者使用了其驾驭不了的特性，比如各种异步、递归、流式等，会用的人一看就知道他用错了，他以一种错误的方式在使用这些特性。《C++沉思录》有一个建议：“你在犹豫要不要用这个 C++ 特性时，那就不要用。”滥用 C++ 特性正是 C++ 臭名昭著的原因之一，所以问题不在 C++ ，而在那些用不好 C++ 特性却非要用的程序员啊。不过，菜就多练，不练怎么变强？开发者使用其不熟悉的特性是不可避免的。
4. 原开发者练完手就甩，这是第3点的延续，就是当原开发者一开始用不好某个特性，随着时间推移他能用好了，但是却留下了一堆练手的屎山代码，这些技术债就留给后来接手的其他开发者去偿还。有责任心的原开发者在能力提升后会回过头去清理掉之前的问题代码，毕竟那代码是他写的。不过也可能是管理者安排原开发者去做其他项目，导致没有时间让原开发者去改掉之前有问题的代码。
5. 原程序员对业务流程不够了解就开始写代码，逻辑混乱，没有条理。还有一种类似的情况，责任不在原开发者，那就是没有产品经理或者需求不明确朝令夕改。也会出现代码的业务逻辑很诡异的情况，一般称之为历史遗留问题。
6. 责任混乱，这是个管理的问题，管理者以管理劳动密集型的方式频繁调配开发人员切换项目，导致各种诡异代码的出现。

