# [草稿]框架

## 上下文管理

- 全局单例
- 控制反转（IoC）、依赖注入（Di）
- 上下文参数

全局单例的好处显而易见，实现简单，使用简单。问题在于应对一些生命周期并非全局的上下文时会有一些不方便。
比如每一个 HTTP 请求上下文在整个请求周期内存在，但是请求结束就应该销毁，这种更常见的做法是通过上下文参数地形式提供。

依赖注入这种形式需要提前注册好工厂，当依赖被使用时会调用工厂生成实例或者直接返回单例。
实现五花八门，不过基本上就是注册提供者（provide） 和在使用者处注入（inject）的形式。
缺点是需要一些学习成本，但是在现在这点并非问题，程序员要学的东西已经多到这点成本无所谓了。
另一个缺点是注入的容器没有构建完成前会有真空期，比如进入 main 函数马上就要输出日志，但是此时连上下文容器都没有，哪来的注入？

上下文参数的优点就是期缺点，必须通过参数传递，在很多层函数调用里一直传递这个参数有一些麻烦，有些框架上没有预设好的地方没办法获得这个上下文参数。
这个限制，其实也是其优点，本身这种设计就是为了控制上下文的范围，无可厚非。

## 图形框架

### 元素的组织

图形框架里的元素组织方式不约而同地采用了多叉树的形式。
不论是采用自定义二进制、HTML、XML、XAML、JSON或者任何自定义的形式，其本质都是一颗多叉树。
有着根元素，由根元素这个节点不断一级级添加子节点元素而填充满整个界面。

#### 第一层，直接通过面向对象的方式表示树，或者函数式的调用来表示树。

那么要构建这样一颗树的方式最直接的方式就是采用面向对象的方式定义节点元素，从创建根节点开始，不断地往其上加子节点。
以下这种伪代码地形式表示了比较原始的开发方式，这几乎就是面向对象语言最早的应用，比如 smalltalk 就因为这种直观的方式而流行一时。

```java
Node root = new Node();
Node lv1 = new Node();
root.children.add(lv1);
Node lv2 = new Node();
lv1.children.add(lv2);
```

下面的伪代码用函数的形式表示了一颗树，ImGUI 就是此类方式，这种方式在其发布后很快得到认可，并在之后出现了 Jetpack Compose、React 等基于函数调用表示树的框架。

```c++
void lv2 () {
    // DO SOME...
}

void lv1 () {
    lv2();
}

void root() {
    lv1();
}
```

#### 第二层，用 XML 类能表示树结构的数据来生成

之后又采用 XML 类语言来组织树结构，这样的结构易于被程序改动，适合让用户通过图形设计软件拖拽摆放就弄好界面。
WinForm、Delphi、WPF、VisaulBasic 等所见即所得的框架开始盛行。
其本质就是通过 XML 类语言来生成类似第一层那样的代码，如果你用断点调试跳进去过 WinForm 的那些生成的界面代码就知道。
某种意义上讲，下面的 XML 等价于上面的 Java 代码，所以利用生成器把 XML 翻译器成 Java 代码就行了。
所以它们并非是取代关系，而是递进关系，XML 的低层还是 Java 代码。

```xml
<root>
    <lv1>
        <lv2></lv2>
    </lv1>
</root>
```

因为函数的方式并不需要这层转换，但是由于函数形式的树结构表示方式出来比较晚，其出来的时候市面上已经有一堆用 XML 来生成第一层面向对象代码的框架了。
所以像 React 并非纯的函数形式，其 JSX/TSX 虽然用函数定义组件，但是元素部分还是用到了 XML 形式。只有 Jetpack Compose 是纯的函数形式。

#### 数据的传递与元素的选中


