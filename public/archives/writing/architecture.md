# [草稿]架构设计

## 人月神话、人月是否有效？

```
旱的旱死，涝的涝死。
```

《人月神话》的观点是单纯地堆人月无法线性地确保项目质量和工期按时完成，因为堆人月的效用是一条收敛的曲线。
这个结论是对于大公司而言的，因为《人月神话》作者的项目经验都是上万人参与的软件工程，也只有他这种才能通过堆人月堆到人月效用的收敛效果显现。
堆人月在前期是非常有效用的，尤其在十个人以内的项目，工作量被分担后项目的进展肉眼可见地加快。
很多小公司因为付不起人力成本，常常希望一个人完成一个乃至多个项目，一个人当几个人用，这个时候就会说到《人月神话》，并指出自己的公司虽然小，但是和上万人的公司比一样的，不能堆人月，堆人月是浪费。

在做架构设计的时候，一定是要考虑到人力这块，而对于小公司而言，往往不需要架构设计，原因无他，没人。

## 确定统一标准

早年在框架设计范畴有一个争论 “Code First” 还是 “Data First"，即以谁为标准。
“Code First” 这一派认为必须以代码为标准，这样的好处是幂等性，只要代码在，那么数据就能被重建。
此类的例子如 数据库的 DDL 和 迁移策略。
“Data First” 这一派认为要以数据为标准，比如各种文件，WinForm、WPF各种拖拉后生成的 UI界面，PS 文件，JSON 配置。
这类认为代码应该去适配数据，什么样的数据，代码就做什么样的事。
很明显，早年间，“Data First”从理论上不可行，因为代码无法适配随意的数据。
不过 AI 到来了，AI 是真正意义上的“Data First” 实现，无论什么数据，都能交给 AI 处理。

从这场竞争中得到什么经验？就是没有绝对的适用，这些场景都是分层的，即便 AI 更低层是通过各种 MCP 实现的文件处理，而低层的单个 MCP 服务明显是 “Code First” 的固定代码编写。如果一个人说他能一招鲜吃遍天，你信了你傻。

那么在确定统一标准的时候，最先要确定的就是开发人物所在的层。而对于一个框架乃至架构而言是由多个层组成的，所以在不同层要做出正确的决定。

比如：
1. 接口层面：Protobuf 通过 CodeFirst 的自定义语言，统一客户端服务器端在不同语言下的接口实现，采用一份代码生成多分代码。
2. 数据库层面：Prisma 通过 CodeFirst 的自定义语言来生成 迁移脚本，数据库 ORM 代码等。
3. 游戏引擎层面：Unity IDE 通过 DataFirst 方式识别文件，通过文件分析来生成 *.meta 文件。

### 一些反例

微信公众开放平台在设计上的诸多问题都是因为在这些问题上处理不好。
同样的问题也出现在阿里云等平台上，不过这很正常，因为此类问题一直都在。

不少框架也有此类问题，比如通过存放在数据库的用户配置来生成界面，在迁移后的项目需要连同数据库一起复制。
而对于要做二开就很不方便，因为功能代码依赖了数据库，导致需要大量手工去迁移数据库数据。

#### 坏设计：框架的权限项存数据库

一般而言，是先有某个功能，后有权限项，而功能又是代码编写而来。
所以更好的做法是写一个代码分析工具，自动分析代码生成所有的权限项的配置文件。
或者手动编码所有权限项，之后用户对权限的管理存数据库倒是无所谓，但是要确保权限项不脱离代码。

## 复制（Replication）

```
鱼，我所欲也；熊掌，亦我所欲也。二者不可得兼，舍鱼而取熊掌者也。——《孟子・告子上》
```

有付出，才有回报。任何的好处都有代价。计算机也不例外，常见的优化手段无非以下两类：

1. 用时间，换空间。
2. 用空间，换时间。

大部分的架构都要面对这样的选择。而随着各种内存条、硬盘等存储单元变得廉价，而 CPU 和 GPU 等算力单元又不断涨价的时代大背景下，“用空间，换时间。”的算法被广泛应用，以此就引出了一个架构最常面对的课题：复制。

数据库主从分离：就是让主数据库和从数据库同时保有多分数据的复制方案，利用多个从数据库复制主数据库的数据来提高可访问量。
客户端缓存：缓存是最常见的复制方案，客户端缓存是让用户保持一份服务器的数据，这样有多少个客户端就有多少份复制的数据。
服务端缓存：服务端缓存是为了减少运算量，把查询结果缓存起来，这样的数据本质是对数据库部分数据的复制，有复制就要确保数据的同步，一般靠删除过时缓存，触发缓存生成的方式来让数据同步。
CDN：网络是有距离的，通过在各个区域部署源仓库的复制仓库，就近访问复制仓库的方式来缩短网络距离，提高访问速度。

## 项目源码管理

由于现代软件开发完整的功能很难只由一个项目组成，比如前后端分离，或者有队列、中台、微服务等，导致一个功能完整的项目会存在多个子项目。
所以代码管理上就会有以下多种方式。这并不是一个马上就成型的东西，而是一个不断演化改进的过程，不同语言通过扩展开发工具来实现，最常见的就是各种语言工具扩展 workspace 功能。go 加入 work 子命令。rust 的 cargo 也有 workspace 这种功能，可以看到此类语言的仓库往往就是多个子项目在同一个仓库里面的。

- 单仓库 Repo：多个子项目汇总在一个 Git 仓库管理。
- 多仓库 MultiRepo：多个子项目独立的 Git 仓库管理。
- 单仓库共享模块 MonoRepo：多个子项目汇总一个 Git 仓库管理，在此基础上通过改良构建工具共用部分代码、依赖等。

## 序列化与反序列化

序列化和反序列化的格式很多，但是 JSON 占了大头，主要也是因为弱类型语言在这些领域占比大。

- JSON：类型太少。
- BSON：MongoDB 定义的二进制序列化结构，类型比较多。
- Protobuf：GRPC 定义的二进制序列化结构，类型稍微比 JSON 多，但是缺少 Decimal、时间类型等，通过自定义 message 来扩展不够方便。
- MessagePack：二进制序列化结构，库靠第三方维护的多，导致不够稳定好用。

## 常规系统

### 互联网系统

特点：并发多，数据精简，服务人群体量大。

互联网主要是以网站、APP为主的开发，用户都是 C 端的，会主动下载 APP 或者访问网站。
互联网公司的策略都是和宣传紧密相关的，买量更是常态。
大部分的开发也是为了让买量的效益最大化。定位客户人群，不讨好谁，只是让喜欢自己的用户发现自己。
互联网公司非常依赖产品经理的眼光，因为都是自己开发自己的，之后投流获客，所以一个产品的好坏，受众多不多，愿不愿意付费都是靠产品经理。
所以产品经理在互联网公司基本上就是 CEO（乔布斯），游戏公司的话就是主策划（黑神话悟空）。
互联网公司在开发的多是以前没有的东西，所以谁也不知道是什么样，只能听产品经理的。

互联网的服务性能差多半是代码问题，因为互联网公司的设备都是用集群，设备上已经拉满配置。
互联网大厂的单个节点 96核2T内存 组几百台的集群。
互联网小公司会使用 16核32G 左右配置的云服务器，按需购买。

### 企业软件系统

特点：并发少，数据繁杂，服务对象少。

企业系统是在已有业务体系开发系统，业务早就成型，大家都知道这个东西要怎么样。
产品经理地位很低，业务都在各个部分经理手里，员工也有自己的想法，各执己见。
不可能让业务适配软件，所以软件只能适配业务，产品经理成了传声筒，每天都在问各种意见。
一句笑话：“企业系统的产品经理路过门房，大爷都能对他指指点点。”
或许这不是笑话，如果他要开发门禁，大爷确实也有发言权。

企业软件很大程度上就是在管理数据，尤其企业软件管理系统各种定义，总结就是要熟悉企业业务。
这也是为什么程序员主要工作是 CRUD 占多，因为企业业务大多这些。小企业更是 Excel 全包办。

- ERP（Enterprise Resource Planning）企业资源计划：注重管理企业内部。
- CRM（Customer Relationship Management）客户关系管理：注重对企业外部客户关系管理。

为什么会有这么多系统分类呢？因为软件公司不够大，要开发完整的企业系统无法实施，所以都划分区域去实现部分功能。
这属于是软件公司一种取巧的方式，因为开发一整套完整的系统如 SIP 耗费人力巨大。
企业软件的硬件部分，这部分需要操作各种硬件设备，软件开发多是与硬件服务商合作对接。
开发企业软件的公司不会自己生产打印机、门禁、显示屏、排号机（打印机+屏幕）、扫描器等硬件设备，而是通过购买这些设备来对接。
一般会在购买后得到这些设备提供商的 SDK 或者技术支持。
同样还是这个问题，要连硬件也生产的成本太大，所以软件公司取巧了。

企业系统软件卡多半是设备老旧，业务功能随时间累加后老设备性能慢慢被占满，基本上都是单机服务器，设备常常都是十来年的老设备。
一两个 4核8G + 几个 1核1G 的云服务器再买些旧设备就能带动日常 几百人 使用。 

### 电商系统（E-Commerce）

电子商务系统是比较普遍的，几乎每个人都网购过，形形色色的电商系统大同小异。因为是 To C 的，设计上都要让用户简便操作，注重用户习惯，所以都趋同了。

- [newbee mall](https://github.com/newbee-ltd) 电商系统
- [mall 后端](https://github.com/macrozheng/mall) 
- [mall 后台 前端](https://github.com/macrozheng/mall-admin-web)
- [mall APP 前端](https://github.com/macrozheng/mall-app-web)
- [Apache OFBiz](https://ofbiz.apache.org/)
- [nopCommerce](https://github.com/nopSolutions/nopCommerce) 技术栈比较旧，后端 .Net Formatwork 4.8（只能 Windows）；前端用 gulp 打包 jquery 项目。

## 权限

在分布式的架构里，不同服务间就需要鉴权，这就包括以下的方式：

- ACL（Access Control List）访问控制列表：账号的授权和鉴权机制。
- STS（Security Token Service）安全令牌服务：临时账号的生成。

## 数据库

### 链接字段

随着云服务盛行，即便很小的项目文件存储也是分布在云端，所以链接必须是全链接已经毋庸置疑，不然在云端会定位困难或者丢失关键信息。

## 文件

### 对象存储

