# 架构

## 人月神话、人月是否有效？

```
旱的旱死，涝的涝死。
```

《人月神话》的观点是单纯地堆人月无法线性地确保项目质量和工期按时完成，因为堆人月的效用是一条收敛的曲线。
这个结论是对于大公司而言的，因为《人月神话》作者的项目经验都是上万人参与的软件工程，也只有他这种才能通过堆人月堆到人月效用的收敛效果显现。
堆人月在前期是非常有效用的，尤其在十个人以内的项目，工作量被分担后项目的进展肉眼可见地加快。
很多小公司因为付不起人力成本，常常希望一个人完成一个乃至多个项目，一个人当几个人用，这个时候就会说到《人月神话》，并指出自己的公司虽然小，但是和上万人的公司比一样的，不能堆人月，堆人月是浪费。

在做架构设计的时候，一定是要考虑到人力这块，而对于小公司而言，往往不需要架构设计，原因无他：没人。小公司的最终方案也是单服务器为主，大多数都是功能的堆砌，这也是为什么屎山很多的原因。

## 编程语言的选择

在选配技术栈的时候无可避免地要考虑到编程语言的选择。
编程语言按类型系统的强弱可以简单地分为强类型和弱类型，而如果细分，每种语言的类型强度是不同的。
强类型语言里 rust 的类型系统就是较强的，go 弱于 rust，Java 弱于 C#。
弱类型语言里 js 类型系统则属于很弱的，很多基本的类型判定都很麻烦。
那么类型系统的强弱有什么影响呢？编写代码速度与类型强度成反比。

1. 类型系统越强，编写代码受到编译器的约束越强，需要写更多类型代码，代码量多。
2. 类型系统越弱，编写代码受到编译器的约束越弱，可忽略很多类型代码，代码量少。

既然类型系统会影响编写代码的速度，为什么 JS 还会派生出 TS 这种语言呢？代码可维护性与类型系统强度成正比。

1. 类型系统越强，给程序员提供的信息越多，代码越可能被规范。
2. 类型系统越弱，给程序员提供的信息越少，代码越可能变混乱。

这就是为什么很多外包公司不愿意接手其他外包公司的项目做维护，因为外包公司多是使用 PHP、JS 这类弱语言开发，代码规模到达一定程度后维护困难。
因为缺少类型约束，外包公司的项目会在一两年内迅速混乱，变得难以维护。
那么外包公司为什么不使用强类型语言开发？因为时间成本，使用强类型语言开发开发周期会变长。

那么应该如何选择呢？

1. 人员少，使用弱类型语言，人员少说明是初创，可能项目半年就死，没有必要考虑那么长远。
2. 人员多，使用强类型语言，人员多说明项目规模大，强类型可以减少人员协同成本，强类型系统能有效规范代码。
3. 因成员习惯而定，大部分程序员并不具备强学习能力，不是你让他用什么语言他拿起来就能用的，所以要根据成员的能力而定。

## 避免“假大空”

假大空的事情很多：

比如在一台 4核8G 的机器上搞高并发优化，既然在使用这种机器，那么用户数量就不可能多，如果用户数量多，也不可能只使用这种配置的机器。一些技术确实可以提升下性能，但是用这种机器的公司单机性能也不是其可以投入去深入算法上做提升的事。投入人力几万块去优化20%的性能提升，到头来不如把机器提升到 8核16G 就一年几千块，性能翻倍。而那些投入几千万去提升20%性能的大公司是因为他们有上万台 128核2T 的节点服务器，提升 20% 的性能将在成本上节省上亿。

比如在一台的机器上搞分布式，分布式是一种“韩信点兵，多多益善。”的技术，本质就是对多机器的管理，机器都没有你管理什么？用管理十万人的方式管理十个人就会导致这十个人的工作量剧增，用管理集群的方式管理一台单机性能很差的机器就会导致机器性能损耗在分布式管理上。这也是为什么现在会很多小公司开始又回到单体项目，因为就没有那么多用户量。

比如在日活百人的网站上要求 IM 要支持万人，之后要可扩展成十万、百万人同时通信，却不愿意采用 NodeJs 的单机最多支持 200 人的 IM 服务。

以上的事其实就是偷换概念，同样是程序员，有的在开发操作系统，有的只是写写网页，差距巨大，虽然从概念，你确实可以说他们都是程序员。这是一种概念混淆，越俎代庖的行为。就像乞丐想象不到皇帝的生活方式，手头上没有那些工作，那些机器，一切都是空想，一切也都是假的、虚幻的、不切实际的。这也是很多小公司一直搞，但是都没搞生成什么的原因，没有踏踏实实做其该做的。

回归到架构上，就是要根据公司规模、业务场景去定制架构。

## 确定统一标准

早年在框架设计范畴有一个争论 “Code First” 还是 “Data First"，即以谁为标准。
“Code First” 这一派认为必须以代码为标准，这样的好处是幂等性，只要代码在，那么数据就能被重建。
此类的例子如 数据库的 DDL 和 迁移策略。
“Data First” 这一派认为要以数据为标准，比如各种文件，WinForm、WPF各种拖拉后生成的 UI界面，PS 文件，JSON 配置。
这类认为代码应该去适配数据，什么样的数据，代码就做什么样的事。
很明显，早年间，“Data First”从理论上不可行，因为代码无法适配随意的数据。
不过 AI 到来了，AI 是真正意义上的“Data First” 实现，无论什么数据，都能交给 AI 处理。

从这场竞争中得到什么经验？就是没有绝对的适用，这些场景都是分层的，即便 AI 更低层是通过各种 MCP 实现的文件处理，而低层的单个 MCP 服务明显是 “Code First” 的固定代码编写。如果一个人说他能一招鲜吃遍天，谁信谁傻。

那么在确定统一标准的时候，最先要确定的就是开发人物所在的层。而对于一个框架乃至架构而言是由多个层组成的，所以在不同层要做出正确的决定。

比如：
1. 接口层面：Protobuf 通过 CodeFirst 的自定义语言，统一客户端服务器端在不同语言下的接口实现，采用一份代码生成多分代码。
2. 数据库层面：Prisma 通过 CodeFirst 的自定义语言来生成 迁移脚本，数据库 ORM 代码等。
3. 游戏引擎层面：Unity IDE 通过 DataFirst 方式识别文件，通过文件分析来生成 *.meta 文件。

### 一些反例

微信公众开放平台在设计上的诸多问题都是因为在这些问题上处理不好。
同样的问题也出现在阿里云等平台上，不过这很正常，因为此类问题一直都在。

不少框架也有此类问题，比如通过存放在数据库的用户配置来生成界面，在迁移后的项目需要连同数据库一起复制。
而对于要做二开就很不方便，因为功能代码依赖了数据库，导致需要大量手工去迁移数据库数据。

#### 坏设计：代码不完备，部分在数据里。

有一段时期出来了一批赶时髦如 DDD 亦或者 低代码 等概念而被设计并创造出来的框架。
要启用某些功能，先通过后台人工操作UI界面添加了一堆配置数据，之后代码围绕这些数据来开发。
这种开发框架会面临一个问题，就是 git 此类工具只对源码做版本管理，而这些框架只有源码是不完整的，数据库里面的配置数据没有的情况下项目根本不能正常运行。这个时候就要手动复制数据库，在操作上多出很多失误的环节，要么复制的时候为了安全少复制几个表的数据，要么因为大意直接复制整表而泄露了关键数据等。而且也不利于工作交接，因为代码交出去后其实还不行，因为还差数据库。
更有甚者，数据库里面存了部分代码源文件，而提交的 git 的是不完整的。
诸如此类的框架设计都存在数据库丢数据的时候整个系统无法恢复的风险。

造成这种情况的根本原因在于开发者和设计者能力的不足，过度依赖数据库，典型的手里有把锤子见啥都只会锤。
同时数据库的使用又只局限在 CRUD 层面，没有运用到诸如 “迁移（Migration）”、“复制（Replication）” 等层面的应用，把低代码简化成了 CRUD 配置。

## 日志（Log）与快照（snapshot）与版本（version）

日志是一套系统的可靠性的基本保障，可以说没有日志，就没有数据可靠性。
从另一方面来说，日志就是数据，数据就是日志。很多探讨的时候直接用日志指代了数据，因为日志可以用来重建数据。
数据库靠 WAL 保证数据的完备，MVCC 保证事务的可用性，快照则可以认为是日志的压缩。
操作系统层面如 Windows 则使用转储文件（可以认为是一种系统日志）来查看某一段时间内寄存器等计算机状态的变化。
而在应用层面日志是查找 BUG 的有效工具，通过翻看有效的日志可以查看到蛛丝马迹。
数据坏了，如果是有效的日志也可以通过日志重建数据，当然前提是日志有效且完备。
应用开发常常是忽略日志重要性的，一方面应用开发注重的是功能开发的进度，更多的时候是靠测试确保功能正常，另一方面应用开发很多时候靠调试器断点，这样的流程容易忽略日志的重要性。
在设计框架和架构时，日志几乎是一定要考虑到的，好的日志系统能快速定位漏洞。


## 复制（Replication）

```
鱼，我所欲也；熊掌，亦我所欲也。二者不可得兼，舍鱼而取熊掌者也。——《孟子・告子上》
```

有付出，才有回报。任何的好处都有代价。计算机也不例外，常见的优化手段无非以下两类：

1. 用时间，换空间。
2. 用空间，换时间。

大部分的架构都要面对这样的选择。而随着各种内存条、硬盘等存储单元变得廉价，而 CPU 和 GPU 等算力单元又不断涨价的时代大背景下，“用空间，换时间。”的算法被广泛应用，以此就引出了一个架构最常面对的课题：复制。

数据库主从分离：就是让主数据库和从数据库同时保有多分数据的复制方案，利用多个从数据库复制主数据库的数据来提高可访问量。
客户端缓存：缓存是最常见的复制方案，客户端缓存是让用户保持一份服务器的数据，这样有多少个客户端就有多少份复制的数据。
服务端缓存：服务端缓存是为了减少运算量，把查询结果缓存起来，这样的数据本质是对数据库部分数据的复制，有复制就要确保数据的同步，一般靠删除过时缓存，触发缓存生成的方式来让数据同步。
CDN：网络是有距离的，通过在各个区域部署源仓库的复制仓库，就近访问复制仓库的方式来缩短网络距离，提高访问速度。

## 项目源码管理

由于现代软件开发完整的功能很难只由一个项目组成，比如前后端分离，或者有队列、中台、微服务等，导致一个功能完整的项目会存在多个子项目。
所以代码管理上就会有以下多种方式。这并不是一个马上就成型的东西，而是一个不断演化改进的过程，不同语言通过扩展开发工具来实现，最常见的就是各种语言工具扩展 workspace 功能。go 加入 work 子命令。rust 的 cargo 也有 workspace 这种功能，可以看到此类语言的仓库往往就是多个子项目在同一个仓库里面的。

- 单仓库 Repo：多个子项目汇总在一个 Git 仓库管理。
- 多仓库 MultiRepo：多个子项目独立的 Git 仓库管理。
- 单仓库共享模块 MonoRepo：多个子项目汇总一个 Git 仓库管理，在此基础上通过改良构建工具共用部分代码、依赖等。

## 序列化与反序列化

序列化和反序列化的格式很多，但是 JSON 占了大头，主要也是因为弱类型语言在这些领域占比大。

- JSON：类型太少。
- BSON：MongoDB 定义的二进制序列化结构，类型比较多。
- Protobuf：GRPC 定义的二进制序列化结构，类型稍微比 JSON 多，但是缺少 Decimal、时间类型等，通过自定义 message 来扩展不够方便。
- MessagePack：二进制序列化结构，库靠第三方维护的多，导致不够稳定好用。

## 关于云服务

云服务就像租房，当规模小时候租房当然是要比买房子实惠得多，也能够马上入住。
云服务本质就是靠着均摊赚钱，云服务构建集群后按需买出赚取利润的可行性就在于上规模后边际成本递减了。
一个小公司自建机房，虽然配置需求很小，但是很多成本还是要单独承当，这就导致成本下不来。
到了一定规模的公司都会考虑自建机房，因为规模上来后云服务就没有性价比了。
其实也很容易想到，如果云服务赚钱，自然是要更有性价比的，云服务的搭建条件就是要规模大。

## 常规系统

### 互联网系统

特点：并发多，数据精简，服务人群体量大。

互联网主要是以网站、APP为主的开发，用户都是 C 端的，会主动下载 APP 或者访问网站。
互联网公司的策略都是和宣传紧密相关的，买量更是常态。
大部分的开发也是为了让买量的效益最大化。定位客户人群，不讨好谁，只是让喜欢自己的用户发现自己。
互联网公司非常依赖产品经理的眼光，因为都是自己开发自己的，之后投流获客，所以一个产品的好坏，受众多不多，愿不愿意付费都是靠产品经理。
所以产品经理在互联网公司基本上就是 CEO（乔布斯），游戏公司的话就是主策划（黑神话悟空）。
互联网公司在开发的多是以前没有的东西，所以谁也不知道是什么样，只能听产品经理的。

互联网的服务性能差多半是代码问题，因为互联网公司的设备都是用集群，设备上已经拉满配置。
互联网大厂的单个节点 96核2T内存 组几百台的集群。
互联网小公司会使用 16核32G 左右配置的云服务器，按需购买。

### 企业软件系统

特点：并发少，数据繁杂，服务对象少。

企业系统是在已有业务体系开发系统，业务早就成型，大家都知道这个东西要怎么样。
产品经理地位很低，业务都在各个部分经理手里，员工也有自己的想法，各执己见。
不可能让业务适配软件，所以软件只能适配业务，产品经理成了传声筒，每天都在问各种意见。
一句笑话：“企业系统的产品经理路过门房，大爷都能对他指指点点。”
或许这不是笑话，如果他要开发门禁，大爷确实也有发言权。

企业软件很大程度上就是在管理数据，尤其企业软件管理系统各种定义，总结就是要熟悉企业业务。
这也是为什么程序员主要工作是 CRUD 占多，因为企业业务大多这些。小企业更是 Excel 全包办。

- OA（Office Automation）办公自动化：集成请假、报销、审批、文件管理等日常办公自动化。
- HR（Human Resource）人力资源：员工在职周期管理。
- CRM（Customer Relationship Management）客户关系管理：注重对企业外部客户关系管理。
- ERP（Enterprise Resource Planning）企业资源计划：注重管理企业内部。

为什么会有这么多系统分类呢？因为软件公司不够大，要开发完整的企业系统无法实施，所以都划分区域去实现部分功能。
这属于是软件公司一种取巧的方式，因为开发一整套完整的系统如 SIP 耗费人力巨大。
企业软件的硬件部分，这部分需要操作各种硬件设备，软件开发多是与硬件服务商合作对接。
开发企业软件的公司不会自己生产打印机、门禁、显示屏、排号机（打印机+屏幕）、扫描器等硬件设备，而是通过购买这些设备来二开。
一般会在购买后得到这些设备提供商的 SDK 或者技术支持。
同样还是这个问题，要连硬件也生产的成本太大，所以软件公司取巧了。
所以此类开发可以总结为：“企业业务的软件化”，其区别只在于业务，技术层面上几乎没有区别。
各种名词无非都是用来来定位缩小实现范围或者干脆就是噱头，其本身的定义也是含糊的。
很多 OA、HR、CRM 慢慢就向 ERP 发展，ERP 也可能因需求而侧重 OA 或者 CRM 方向。

企业系统软件卡多半是设备老旧，业务功能随时间累加后老设备性能慢慢被占满，基本上都是单机服务器，设备常常都是十来年的老设备。
一两个 4核8G + 几个 1核1G 的云服务器再买些旧设备就能带动日常 几百人 使用。 

### 电商系统（E-Commerce）

电子商务系统是比较普遍的，几乎每个人都网购过，形形色色的电商系统大同小异。因为是 To C 的，设计上都要让用户简便操作，注重用户习惯，所以都趋同了。

- [newbee mall](https://github.com/newbee-ltd) 电商系统
- [mall 后端](https://github.com/macrozheng/mall) 
- [mall 后台 前端](https://github.com/macrozheng/mall-admin-web)
- [mall APP 前端](https://github.com/macrozheng/mall-app-web)
- [Apache OFBiz](https://ofbiz.apache.org/)
- [nopCommerce](https://github.com/nopSolutions/nopCommerce) 技术栈比较旧，后端 .Net Formatwork 4.8（只能 Windows）；前端用 gulp 打包 jquery 项目。

## 权限

在分布式的架构里，不同服务间就需要鉴权，这就包括以下的方式：

- ACL（Access Control List）访问控制列表：账号的授权和鉴权机制。
- STS（Security Token Service）安全令牌服务：临时账号的生成。

## 数据库

### 链接字段

随着云服务盛行，即便很小的项目文件存储也是分布在云端，所以链接必须是全链接已经毋庸置疑，不然在云端会定位困难或者丢失关键信息。

## 文件

### 对象存储（Object Storage）

