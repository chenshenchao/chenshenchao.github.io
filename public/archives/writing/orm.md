# [草稿] ORM（Object-Relational Mapping）的设计

数据库几乎是每一个软件都必须使用的，不管是嵌入在软件内部的 SQLite 亦或是 作为服务的 PostgreSQL、MySQL、SQL Server 等。
数据库有自己的语言 SQL ，所以早期使用数据只需要一个客户端 Client 连接数据，通过 SQL 操作数据库。
由于 SQL 作为另一种语言，在各种软件开发的主语言里作为字符串被拼接缺少类型检查，有被注入的风险，就有了 ORM 这种库。
随着对 SQL 使用的深入，ORM 不满足于拼接 SQL ，各式各样的功能被加入其中，迁移（migration）、数据库优先（DbFirst）、代码优先（CodeFirst）被加入。

- DbFirst 根据已有数据库表结构生成 ORM 使用的数据结构类型。
- CodeFirst 通过主语言的数据结构自动建表，只是主语言结构到建表是不够的，会有很多问题，见下 Migration。
- Migration 通过代码生成数据库表结构，是 CodeFirst 更进一步，有版本管理，幂等性，可以重建回滚数据库，这样项目被复用也能快熟生成新的数据库。

从 CodeFirst 到 Migration 的过程是优先的，因为不管是 强类型语言 还是 弱类型 语言，对这部分的需求都是一样的。
但是 DbFirst 这个方向却发展缓慢，一方面 弱类型语言没有 DbFirst 的需求，DbFirst 是生成类型的，弱类型就是要弱化类型。
强类型语言，又面临以下的问题：
“查询返回结构”、“插入结构”、“修改结构”和“数据表结构”不一致。以用户为例，密码和盐字段 查询时是不查的，插入时传的只由字符串类型的密码，而真实表结构可能是盐和加盐 HASH 后的二进制类型。典型的“修改结构”是 ID 或 账号 是不能改的。
这就导致项 diesel 这种直接放弃这一步，让使用者自己定义结构体。
而 sea-orm 则是会生成一个以表结构主的结构，这样就只需要定义 查询结构，插入时使用这个生成的结构，而接口的插入参数属于 web 框架的范畴让 web 框架解决。
不管是 sea-orm、EfCore.NET 还是 gorm 都有生成用于查询的结构，这个结构在大多数场景下都不好用，因为会导致所有字段被查出来，并且无法使用应对复杂的 SELECT 语句。这些框架也花了很大力气在查询上，但遇到复杂查询，就会退化成废弃掉生成的结构，转而自定义结构并使用底层的 SQL 拼接而非模型。
查询结构的问题在于，不是单一的结构，一张表被不同业务逻辑查询时需要返回的字段是不同的，所以是一对多的情况，其特点是大部分字段相同，少部分字段不同。

prisma 的 CodeFirst 更进一步，与以往靠迁移脚本来确保数据库不同，其规定 CodeFirst 的数据结构、迁移脚本、当前数据库表结构三者强一致性，同时自定义结构表示语言 prisma 语言（类似 Protobuf 的语言）作为中间统一介质确保强一致性，同时生成原先的 CodeFirst 数据结构、迁移脚本、运行迁移脚本同步数据库结构的整合操作。
缺点是迁移脚本是生成的，添加 插入初始化数据就要改动脚本破坏三者的强一致性，导致需要整个数据库删除重建，不可性，所以初始化数据要另外做。
