# [草稿]语言

语言是思考的工具，使用什么样的编程语言决定了你对程序的理解。
所以面对不同的问题，最优的解决方式几乎就是为这个问题创造一门语言。
比如人们为了解决数学问题，创造出了数学语言。
从此 “1 + 1 = 2” 而不是 “一加一等于二”，或者 “One plus one equals two” 地表达。

开始学编程，也是从学习某种语言开始地，单一地使用某种语言是不可能的。
你会在开发种不断地学会各种语言。
从最简单的 HTML、CSS、JS、正则、SQL 这些常用的专用语言，没有这些你几乎不可能完成你的 Web 项目。
同时你还要学会自己的主语言，如 Java、C#、Python、Go、PHP 这些。
随着项目的复杂度增加，单一的主语言也不可行，你需要使用多种语言。
比如一个 Python 写的 AI 端配上你原先使用的 Java Web 端和用 C# 写的 Unity 游戏客户端。

多语言有个巴别塔的魔咒，就是语言会增加沟通成本，所以你会需要各种诸如 JSON、Protobuf、XML 用于 API 或 RPC 传递数据的语言。

编程很大程度上是个偏向语文的工作，编写代码就像写作。“算法工程师”这种偏向数学的岗位被单拎出来。

语言既然对编程如此重要，编译器的开发在计算机开始之初就一直进行到了现在，没有停过。
是不是你就会听到一个新语言发布，或者某某库发布了，你进去一看，这个库又引入了一种新语言。
这种语言可以很简单且很像某个已有语言，比如：

1. Protobuf 为数据结构定义设计。
2. Prisma 为数据库设计。
3. go-zero 的 API 为接口设计。

## 设计

### 代码块（Block）

代码块。

- “固定 { 开头” 配 “固定 } 结尾” 的大括号：C、Java、Go 等一众语言都使用这种方式，容易实现。
- 缩进：Python 使用，编译器麻烦，新手写代码也容易写错，好处是代码相对整齐易读。
- “不定 token 开头” 配 “固定 end 结尾” ：Pascal、Delphi、Ruby 等都使用这种，编译器上省了一个 token 分析，坏处是如果排版不好不太容易看出 end 配对的 token。
- 函数式调用：Haskell、Lisp 此类函数式语言的代码块是以函数调用的形式表示，全是表达式，没有过程式语句。好处是可以柯里化，坏处是没有过程式直观。

### 关键字（keyword）

关键字的风格形形色色：

- 极简缩写：Rust 就是这种 fn、i8、u8、dyn 等，都是尽量把关键字做短。
- 稍微缩减：Go 的 func、python 的 def 和 Kotlin 的 fun 这种都稍微缩减了关键字的大小。
- 奇怪缩减：Perl 的 elsif 这种。
- 尽量全拼：PHP 和 JS 都使用 function 、C# 和 Java 也是用 public、private 这种全拼的长单词。
- 尽量不要关键字：函数式语言会尽量用函数去取代关键字，Lisp 这种动态语言连 define、let 都是函数，所以很多在其他语言里是关键字的东西，在函数式语言里只不过是一个函数名。

### 标识符（identifier）

- 带前缀：PHP 的变量带 $ 前缀，Perl 的带各种 $、@、% 前缀，Ruby 有 $、@ 来定义变量名，这样的好处是编译器相对容易写，代码也容易读。
- 不带前缀：C、Java、C# 等的变量都是这种，这种比较容易被程序员接受，坏处是不能直观看出变量的某些特性。

### this、self

- 隐式：C++、Java、C# 的 this 一般可以不写，但是这样阅读就不直观。
- 显式：Go、Rust、Python 都需要显式写 this、self 来表明是访问了成员。

### 继承（Inheritance、Derive）与组合（Compose、Mixin、Trait）

- 继承：面向对象采用继承来复用代码，子类通过继承父类得到父类的特性，单继承多接口或者多继继承都或多或少有问题，因为继承是以类为单位，粒度太大。
- 组合：经过十几年的面向对象开发，面向对象的很多特性受到批判，继承就是其中之一，后来的语言使用组合来取代继承，这样粒度就变小了，更好地控制代码的复用。

### 错误与异常处理（error、exception）

- 返回错误：操作系统这种低层的如 C 或者 Rust 、Go 都倾向于把错误通过返回值返回，鼓励尽早处理错误，性能好些。（Rust 和 Go 也是有 panic 这种异常机制的，只是不鼓励用。）
- 抛出异常：应用层面更倾向于把错误往外层抛出，这样方便统一处理错误，鼓励让错误延后到集中处理，缺点是有异常处理的性能损耗。
- 全局状态：操作系统如 Windows GetLastError 获取最后错误的方式，主要是状态机应用比较多，缺点明显，只能看到最后的错误，所以错误要尽早处理，比返回错误还要严厉，好处是性能是最好的，实现也简单。
- 链式状态：错误状态可以在链式状态里保存，只要带错误状态之后的链式方法都会失效并在最后触发错误处理。

### 链式或流式（Flow、Stream、Chain）

链式是面向对象和函数式的混合物，分纯链式和不纯链式。
纯链式要求每次调用返回值必须是新的，没有副作用，配合栈的性能很高，而且不同阶段的返回值都可以被复用。
不纯链式返回值都是 this ，这个返回值不能随意被复用，因为其整体是个状态机，复用会互相干扰，很多 BUG 就是复用了这种不纯链式导致的。

大部分语言在处理数据流时都会采用链式调用的方式：Java 的 Stream、Kotlin 的 Flow、Rust 的流式，都采用链式调用的编码方式。
异步处理如：Js 的 Promise、C# 的 Task、以及 Rust 的 Feature 等都使用了一定层度的链式调用设计。

## 实现

只是单纯地靠 AST 来解释执行程序是很低效的，原因：

1. AST 是以树节点的形式分散在内存的，现代 CPU 都是靠着多级缓存提高效率，分散的内存缓存命中率很低。
2. AST 缺少虚拟机以栈或者寄存器形式预先分配好内存，动态分配频繁。

这就是为什么虽然可以直接就用 AST 运行程序，但是很多语言还是要带个虚拟机，把 AST 转换成字节码的原因。

## 编译原理教学语言

在学习编译原理的时候，教程都会从头开发一款语言，而这些语言形形色色各有特点，会根据教程的侧重点去设计。
在开发一款编程语言编译器或解释器的时候要明确这款语言有哪些特性，支持哪些语法，那么怎样取舍最好的做法就是去参考已有的语言。
这些语言都是模仿了现今流程的语言设计的，为了简化编译器的开发难度，语法上做了一定程度的简化和修改。

### LLVM 示例的 toy 语言

toy 作为 LLVM 的示例，几乎每个开始学 LLVM 的人都会跟着教程实现这门语言，它是模仿 python 设计的。
为了简化开发，使用了 var 这种前置关键字来定义变量，使用 {} 来包裹块。

### 《两周自制脚本语言》的 Stone 语言

Stone 是“石头”的意思，因为作者是日本人，致敬 Ruby（红宝石）而取了个谦虚的名字。
虽然可以说像 Ruby ，实则更像 toy，这大概是简化编译器的结果。

### 《自制编程语言》的 crowbar 和 Diksam 语言

### 《游戏脚本：高级编程》的 xscript 和 xasm 语言

### 《编程语言的设计与实现》的 [Streem 语言](https://github.com/matz/streem)

这个语言是根据 Stream 而创造新词而来的，为的就是区分 Stream 而又是 Stream 的意思。
