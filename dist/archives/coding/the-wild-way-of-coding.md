# 编码的荒野之道

## 程序开发的坎

在做程序开发时总会有不少道坎。

### 沦为“技术狂热分子”

新手因为见得少就仰视技术，过高地看待技术。每学了一个技术或者技巧就好像自己得到了一件宝物沾沾自喜，就觉得这个库或者技巧无所不能。不能正确地看待这项技术，并用这个技术解决问题。误入“为了用技术，而用技术。”的误区，常常项目里一堆不应该用的技术，最后把项目搞成“使用不当技术堆砌的屎山”。

有一个同事，他成天就喜欢找公司的技术管理层聊技术，每天都是：“这个技术好牛逼”，“那个技术快多了。”这种说辞。我和几个同事看了直摇头，就知道他应该刚做开发不久，这种“技术狂热”只有在新手阶段才有。

他经常去找的那几个管理层实则技术稀松平常，时长几个技术问题就谬论一堆。就比如：“TCP服务器连接数限制是端口数量占用太多。”这种谬论。他估计是做测试时，并发运行了多个示例TCP的服务器和客户端把端口占满了，就得出了这个谬论。实际开发的场景下，服务器仅需占用一个端口，客户端每个占用一个端口，太多个客户端才有可能把端口占满，但是客户端是运行在用户的机器上的，也不可能出现这么多客户端在同一个机器，造成这么多客户端是因为要做测试，模拟多个用户的客户端，导致测试机器上的客户端太多的结果。也就是客户端占用端口过多只会在测试阶段出现。

后来他渐渐也发现了问题，开始平视技术，以前的“技术狂热分子”也就变正常了。后来他离职了，留下了几个屎山项目，让公司的同事煎熬了好几年。

### 沦为“调库侠”

大部分的程序员都在使用少部分程序员写的库。只有这样的分工才能使得项目进度可预期且功能稳定。但也恰恰因为如此，导致大部分程序员都沦为了“调库侠”。
现在“云服务”盛行，更是简化了使用，进一步让大部分程序员沦为“云调库侠”。

我曾在一家公司工作七年，七年间技术没有长进。而我却用了七年才发现这一事实，期间有多个同事都用了一两年就发现了这个事实，他们要么选择摆烂转管理，要么开始钻研低层算法，要么直接离开寻求发展。
这是一个程序员经常陷入的坎，开发时使用他人成熟多年的库，这样我们就陷入了一个循环：

1. 看文档
2. 运行示例
3. 整合示例到项目

因为世界上的库几乎每天都在更新，所以即便同一个库，间隔一段时间还是要去查看它的文档，重新走一遍新版本的示例，再把自己项目里使用的这个库升级下版本。（当然版本断代了，出现不兼容，升不上版本的库也不少，也是挺困扰开发者的。）

当时的我，每天应对需求，就去各种网上（主要是 GitHub ）找库，然后每天都觉得自己学到了东西，直到第二年有个同事他说：“其实每天都在看文档，试库用库，挺无聊的，你有什么想法吗？”我突然不知道怎么回他，只是说：“用新库也是一种技术积累。”显然他不满意这个答案，他渐渐对代码的兴趣转淡，我们交流技术也越来越少。
第三年，来了个新同事，他对技术保有热情，所以我和这个新同事交流技术比较多。我们每天看文档试库用库，直到有一天我发现他上班在看很多算法书籍。我对他说：“这些算法都有现成的库，即便按书本写了的代码也不稳定，别人的库都是写了数年乃至数十年，一堆人使用过审计过发现BUG后被作者修正。你即便写出来几个月内都不能稳定使用的。”他当时觉得我是在说他上班摸鱼就说：“我也是用了这个库就找些相关的资料了解下它的实现而已，虽然不学造车也能开车，但是还是想看看发动机怎么转的。”。第四年，他要辞职，我挽留他，他撂下一句：“在这里做久了，人都要废掉了。”就走了。
第五年，来了个新同事，一来他就被分配了一堆任务，我当时要协助他完成他的项目，基本上还是那套看文档试库用库的流程。然后我们就开始选型，他试试了很多库，效果都很不理想。我因为早年写过一些 WPF 就跟他推荐 WPF ，他很犹豫，说他之前没怎么写接触 WPF。交流下我看出他之前应该很少写图形界面，因为他不知道如何设配设计稿（其实就是以设计稿宽度做基准变换长度）。所以我就给他写了几个 Demo 完成部分功能，再把UI的设配跟他说下，他就很快自己把项目做起来了。然后我就发现，他从一开始说：“哎，PC 的框架和库界面就是太丑了，不仅界面老旧，代码还很脏乱。”变成了“WPF 真是完美，几乎什么界面都能做。”转变之快就在一两个月间。之后他接了公司的 IOS 的项目，有次我们去喝咖啡，他跟我说要做一个项目，我说了很多做这个项目的难点，试图推脱掉这个项目。他以为我畏难（实则我是不想做，手头烂事太多，这明显他被主管PUA了啊）就鼓励我，跟我说：“其实我 IOS 是来公司学的，边做边学，什么技术问题都有解决方法的。”我当时说：“嗯。”（看推脱不掉只能做了。），内心却是在想：“这还用你自己说，我早看出来了。你写 WPF 那会连 UI 都不知道怎么设配设计稿，你来公司时不会写 UI 这点我早知道。不知道怎么设配设计稿自然就应该没写过什么 UI 项目，这 IOS 你应该也是不会的。我是畏难吗？你看看工作清单，现在倒好，你被PUA，成天接项目，工作表排了一年多。你自己一个人就算了，还老是拉我下水。”在工作两年后，这个同事一分工资没涨也走了，成了一家小公司的技术管理者。

很多东西其实就几个核心点，比如 “UI 设配设计稿”，之后 UI 技术就只剩下看文档熟悉使用了。我开始意识到自己数年来这套“看文档试库用库”的方式导致了自己技术停滞而不自知，因为每天都在用新库，就这样把自己麻了。

这么多个同事，他们都比我聪明多了，他们仅用一两年就意识到这个问题，并做采取了行动，我意识到这个问题了用了太久，随后我和他们一样选择了离职。

### 沦为“沉迷技术的工具人”

要注重结果，而不是一味的把时间用在学习技术上，尤其很多技术其实只是你学过的某个技术的另一种实现罢了。

一个好的产品，程序员的工作可能都占不到四分之一。乔布斯是产品经理，张小龙是产品经理，雷军也是卸下了程序员的工作后专注产品开发上，为什么不是一个程序员出名做领导？

我们以前端界面为例，当你开发了一个用户体验不错的页面后心情不错，为这个好看的界面开始沾沾自喜，觉得自己技术很强。但是这个用户体验的功能逻辑实际上是产品经理想出来的，界面的美观是 UI 设计师的劳动成果。而你只是一个用代码把他们的劳动成果实现成页面的工具人。一个页面的好坏，技术在这个例子里可能占不到三分之一。尤其是现在流水线的前端技巧，可以在有设计稿的情况下稳定输出页面。

大部分的小公司，老程序员都要承担架构设计的工作。但是小公司的业务也使得他的架构并不好设计，其特点就是机器少且性能差（节约成本，服务器也就一两个，都是4C8G配置的机器，更甚者如 PHP 这种胶水语言把工作都压到了 MYSQL 数据库服务器或者云服务器上了。所以会看到 8C16G 的 MYSQL 云服务数据库配置高过WEB服务器的情况。）面对这种情况在做架构设计时是没有太多操作空间的，往往都是对网上熟知的架构做精简后予以使用。可想而知，这么多人使用的成熟架构，每个部件都有其存在意义，而因为没有机器而做精简自然就会有精简的弊端。常常是分布式的砍成了单节点部署（单个节点自然这个节点故障就等于全部宕机），分布式数据复制改成了同个数据库表读写（读写同个表就各种竞抢导致锁表）。而当你和管理者提及问题时，得到的往往是负面的结果。大部分管理者只想听到技术的优点，和他们说太多技术的缺点，他们不会觉得这项技术本身有问题，而只会觉得是你技术差。差不多的成品结果，经常说优点的程序员会被管理者更看重。

架构设计是需要匹配业务需求的，所以需要你足够了解业务本身。架构设计本质上并非一个单纯的技术问题，大多时候对所在行业的业务需求了解深比技术好更能解决问题。我反思我自己，就是没有很好地理解行业业务需求导致吃了不少亏。

很多时候善于沟通对行业了解且有产品思维的程序员是会直接把有问题的功能尽量砍掉的。你会发现，轮到他做时，有问题的功能都被砍掉了，而轮到你做时一堆不合理的功能都是你的，最后功能做出来问题就各种改或者最终被砍掉了。他砍掉了功能没做就没错，你做了各种问题反而都觉得是你有问题。

在大多数小公司里，技术部门并非主要部门，其公司里销售、运营岗位要比技术岗位更重要。技术部门只是个辅助公司业务开展的部门，这个时候技术人还不自知地只钻研技术就会沦为“沉迷技术的工具人”。你是越做越多，没有回报，每天都在做没办法精进的技术重复，一个项目转下一个项目。每天感觉都自以为过得充实，实则就是陷入“看文档，试库用库”的怪圈，可替代性太强了。

### 沦为“野生程序员”

一直在小公司工作的程序员，最后多是沦为“野生程序员”，就是什么都能做，但是大厂用的那些东西你都没有机会做，因为小公司没有应用场景，也没有资源去做。尤其现在小公司大量使用云服务，可以说小公司已经沦为大公司的端口，数据基本都托管在大公司的云服务上。而大部分小公司程序员沦为“调云侠”。

“调库侠”在企业没有技术根基地时候是需要的技术人才，但是当企业有几个这样的人才后会发现“调库侠”太可替代了。基本上一个不熟悉业务的应届生，只要老员工愿意带，几个月就能完全熟悉“调库侠”的工作。这也是程序员35岁事业危机的根源。大厂实则“调库侠”工作者也不少，只有少部分在研发库或框架的部门开发者能免除这一危机。不过大厂“调库侠”的好处在于他可以卖课，网上一堆这种大厂“调库侠”的课程在售卖。“野生程序员”的优势在于可以给创业小公司做初期技术构建，毕竟小公司的什么都做过。

### 独立开发

程序员如果想要一直做下去，大概就只有开发开源项目并成为维护者这样一条路。只有当你的库或语言或框架被更多的人使用时，你才与这个世界密不可分。

##

编程是写作，现代工业化的软件开发又使得程序员不同于作家(目前网络小说也有工业化的迹象，知名作者有雇佣几个写手的情况)，需要多人协作创作。
一个作家尚且会在其小说中留下前后文不能自洽的文字，编程的多人协作就导致了 BUG 横生。


## 程序开发层

开发工作被分工分层。

![开发层](/graphics/dev-level.svg "Development Level")

产品开发：需要的能力是语言能力，其工作更接近文员，CRUD 就是此类文职工作，大多工作都有最佳实践，按部就班即可。
架构开发：需要的更多是整合能力，其工作本质是整合架构、开发库和工具，定制协作流程，让开发成员的代码更好协作。
基础开发：需要的是算法能力，其面对的多是技术层面的或者算法层面的问题。

可以看到开发是逐层往上的，但这只是理想情况。
现实会出现在做产品开发的时候有个需求架构没有集成某个算法支持。
要求架构师找个支持此算法的库加入到架构里面，却发现市面上没有现成的库，此时开发者需要自行实现这个算法。
所以往往小公司没有成体系的技术，在没有完备的技术架构的情况下进行开发。
小公司程序员常会使用一些现成架构做二次开发，在有现成库的情况下引入到架构里，再自己补足一些没有现成的算法。
二次开发可以保证程序员大部分时间都在做产品开发，只有少部分时间做架构和基础开发(因为用了第三方的架构和基础库)。

所以同样是开发，由于侧重的开发层不同，同样是开发一个商城，大公司要投入很多人在底层做架构或者基础开发，而小公司只要数个人在高层做产品开发就可以。
而侧重于哪个开发层，完全由开发资源和需求决定，小公司没有那么多人力资源一般都是没办法向深度的底层进军的，只能在高层做浅度的开发。

## 类比

### 类比医生

打印日志 就类似 医生让病人去做检查（血常规，CT）这些。所以日志是解决问题最重要的手段之一。如果连状况都搞不清，又怎么对症下药？

## 起初

信息的传播是这个世界普遍存在的，而人类要理解和利用这些信息，就需要对其现象赋予意义，这个意义的过程再数学上就是编码。

有一个电信号，当它高电平是我们记为1，低电平时记为0。本质上这种行为和我们认为硬币的正面记为1，背面记为0是类似的行为。

你可能会疑惑，高电平时记为1，低电平时就不能记为-1吗？这样不是更对称。这是出于编码更方便计算才使用前者。本质上电信号这个现象不会因为你记为0还是-1所影响。也就是编码不会影响被编码的本来性质，而只是给予一种意义。而你的编码方式决定了有多方便。

这种1和0的编码就是二进制的编码，多个电信号归为一组就可以表示更大的数据，这就有了多种编码方式。计算机中常说的 二进制数据 和 字符串数据 其本质上都是 0 和 1 的串。只不过 字符串 数据多了一层意义，也就是编码。给定一个 字节存放 65 这个数字，当你认为他是个 8位整数时它就是 65，当你认为他是一个 ACSII 编码字符时，它就是 A 。本质上他们都是一串 0 和 1 串起来被编码为 65 这个值的一个字节。但是当你赋予它一层意义的时候（也就是编码的时候）它就有了不同的意思。

编码就是这么奇怪，它不改变原有的事物，而且可以层层套进，一个高低电平信号就这么变成了 0 和 1 的串再变成了数字 65 再到字符 A。这个过程它还是一堆高低电平，而且你还可以再给定一个定义，比如我就定义它为“!@#$”这串奇怪的东西，也是可以的。但是既然是要让别人能用来和你一起使用就需要标准，这就是和秦始皇统一度量衡一样有着各种标准，比如刚才说的 ASCII、UTF8、UTF16，如果别人编码用 UTF8 ，而你解码用了 UTF16 就会出现乱码。所以乱码是由于标准（字符集）没对上。

这个时候一大概意识到，这个和日常生活中的“暗号”是一个东西，没错，这也就是为什么计算机会难懂。因为它是多层“暗号”叠加嵌套的东西，就像俄罗斯套娃。要理清就必须层层“暗号”找到映射关系（码表等）层层推导下去。

